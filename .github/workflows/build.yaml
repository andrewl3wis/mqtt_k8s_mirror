name: Test Go Program with kind and MQTT

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  amd64-build:
    runs-on: ubuntu-22.04

    steps:
      # Check out the repository
      - name: Checkout code
        uses: actions/checkout@v3

      # Set up Go
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '=1.23.4'  # Exact version match
          check-latest: true
      
      # Cache Go modules
      - name: Cache Go modules
        id: go-mod-cache
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-amd64-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-amd64-

      # Ensure Go module cache has correct permissions
      - name: Set Go module cache permissions
        run: |
          sudo mkdir -p ~/go/pkg/mod
          sudo chmod -R 777 ~/go/pkg/mod
          sudo mkdir -p ~/.cache/go-build
          sudo chmod -R 777 ~/.cache/go-build

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Set up Docker cache with proper permissions
      - name: Set up Docker cache
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-amd64-${{ hashFiles('**/go.mod', '**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-buildx-amd64-

      - name: Prepare buildx cache directory
        run: |
          sudo mkdir -p /tmp/.buildx-cache
          sudo chmod -R 777 /tmp/.buildx-cache

      # Build AMD64 binary in Docker
      - name: Build AMD64 binary
        run: |
          # Create builder instance with cache
          docker buildx create --use --name amd64-builder

          # Create Dockerfile for AMD64 build
          cat > Dockerfile.amd64 <<EOF
          # Dependency stage
          FROM golang:1.23.4-bookworm AS deps
          
          # Cache apt packages
          RUN rm -f /etc/apt/apt.conf.d/docker-clean && \
              echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/keep-cache
          
          # Install build dependencies with cache
          RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
              --mount=type=cache,target=/var/lib/apt,sharing=locked \
              apt-get update && apt-get install -y \
              libgpgme-dev \
              libbtrfs-dev \
              pkg-config \
              file

          # Cache Go modules with proper permissions
          WORKDIR /go/src/app
          COPY go.mod go.sum ./
          RUN --mount=type=cache,target=/go/pkg/mod \
              mkdir -p /go/pkg/mod && \
              chmod 777 /go/pkg/mod && \
              go mod download

          # Build stage
          FROM deps AS builder
          WORKDIR /go/src/app
          
          COPY . .

          # Build the binary with detailed logging
          ENV GOTOOLCHAIN=local
          ENV CGO_ENABLED=1
          ENV GOARCH=amd64
          ENV GO111MODULE=on
          RUN go build -v -o kube-mqtt-mirror-amd64 && \
              echo "=== Binary Info ===" && \
              file kube-mqtt-mirror-amd64 && \
              echo "=== Dependencies ===" && \
              ldd kube-mqtt-mirror-amd64
          EOF

          # Build using buildx with enhanced caching
          docker buildx build \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --output type=local,dest=. \
            --progress=plain \
            -f Dockerfile.amd64 .

          # Move cache to prevent cache growth
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

          # Create symbolic link for testing
          ln -s kube-mqtt-mirror-amd64 kube-mqtt-mirror

      # Upload AMD64 binary as artifact
      - name: Upload AMD64 binary
        uses: actions/upload-artifact@v3
        with:
          name: kube-mqtt-mirror-amd64
          path: kube-mqtt-mirror-amd64

  arm64-build:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Set up Docker cache with proper permissions
      - name: Set up Docker cache
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ hashFiles('**/go.mod', '**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Prepare buildx cache directory
        run: |
          sudo mkdir -p /tmp/.buildx-cache
          sudo chmod -R 777 /tmp/.buildx-cache

      - name: Build ARM64 binary in Docker
        run: |
          # Create builder instance with cache
          docker buildx create --use --name arm64-builder
          # Create Dockerfile for ARM64 build with multi-stage build
          cat > Dockerfile.arm64 <<EOF
          # Dependency stage
          FROM --platform=linux/arm64 golang:1.23.4-bookworm AS deps
          
          # Cache apt packages
          RUN rm -f /etc/apt/apt.conf.d/docker-clean && \
              echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/keep-cache
          
          # Install build dependencies with cache
          RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
              --mount=type=cache,target=/var/lib/apt,sharing=locked \
              apt-get update && apt-get install -y \
              libgpgme-dev \
              libbtrfs-dev \
              pkg-config \
              file

          # Cache Go modules with proper permissions
          WORKDIR /go/src/app
          COPY go.mod go.sum ./
          RUN --mount=type=cache,target=/go/pkg/mod \
              mkdir -p /go/pkg/mod && \
              chmod 777 /go/pkg/mod && \
              go mod download

          # Build stage
          FROM deps AS builder
          WORKDIR /go/src/app
          COPY . .

          # Verify Go environment
          RUN echo "=== Go Environment ===" && \
              go version && \
              go env GOARCH GOOS CGO_ENABLED GOTOOLCHAIN

          # Build the binary with detailed logging
          ENV GOTOOLCHAIN=local
          ENV CGO_ENABLED=1
          ENV GOARCH=arm64
          ENV GO111MODULE=on
          RUN set -ex && \
              echo "=== Building with flags ===" && \
              go env && \
              go build -v -x -o kube-mqtt-mirror-arm64 2>&1 | tee build.log && \
              echo "=== Binary Info ===" && \
              file kube-mqtt-mirror-arm64 && \
              echo "=== Dependencies ===" && \
              ldd kube-mqtt-mirror-arm64 && \
              echo "=== Copying Dependencies ===" && \
              mkdir -p /build/deps && \
              ldd kube-mqtt-mirror-arm64 | \
              grep "=> /" | \
              awk '{print $3}' | \
              xargs -I '{}' bash -c 'mkdir -p "/build/deps/$(dirname {})" && cp -v "{}" "/build/deps/{}"' && \
              echo "=== Copied Files ===" && \
              find /build/deps -type f -exec ls -l {} \;

          # Final stage
          FROM --platform=linux/arm64 debian:bookworm-slim

          # Install runtime dependencies
          RUN apt-get update && apt-get install -y \
              libgpgme11 \
              libbtrfs0 \
              file

          # Copy binary and all dependencies
          COPY --from=builder /build/kube-mqtt-mirror-arm64 /kube-mqtt-mirror-arm64
          COPY --from=builder /build/deps/ /
          
          # Verify environment and dependencies
          RUN echo "=== System Information ===" && \
              uname -a && \
              echo "=== Library Search Paths ===" && \
              ldconfig -v 2>/dev/null | grep -v "^$" && \
              echo "=== Binary Dependencies ===" && \
              ldd /kube-mqtt-mirror-arm64
          
          # Verify binary and its dependencies
          RUN echo "=== Binary Info in Final Stage ===" && \
              file /kube-mqtt-mirror-arm64 && \
              echo "=== Library Dependencies ===" && \
              ldd /kube-mqtt-mirror-arm64 && \
              echo "=== Library Files ===" && \
              ls -l /usr/lib/aarch64-linux-gnu/libgpgme.so* && \
              ls -l /usr/lib/aarch64-linux-gnu/libbtrfs.so*
          EOF

          # Build using buildx with enhanced caching
          docker buildx build \
            --platform=linux/arm64 \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --output type=local,dest=. \
            --progress=plain \
            -f Dockerfile.arm64 .

          # Move cache to prevent cache growth
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Upload ARM64 binary
        uses: actions/upload-artifact@v3
        with:
          name: kube-mqtt-mirror-arm64
          path: kube-mqtt-mirror-arm64

  test:
    needs: [amd64-build, arm64-build]
    runs-on: ubuntu-22.04

    steps:
      # Check out the repository for test files
      - name: Checkout code
        uses: actions/checkout@v3

      # Download binaries
      - name: Download AMD64 binary
        uses: actions/download-artifact@v3
        with:
          name: kube-mqtt-mirror-amd64

      - name: Download ARM64 binary
        uses: actions/download-artifact@v3
        with:
          name: kube-mqtt-mirror-arm64

      # Make binaries executable and verify
      - name: Make binaries executable and verify
        run: |
          # Make binaries executable
          chmod +x kube-mqtt-mirror-amd64 kube-mqtt-mirror-arm64
          ln -s kube-mqtt-mirror-amd64 kube-mqtt-mirror

          # Verify binary architectures
          echo "=== AMD64 Binary Info ==="
          file kube-mqtt-mirror-amd64
          
          echo "=== ARM64 Binary Info ==="
          file kube-mqtt-mirror-arm64

      # Install minimal runtime dependencies
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            mosquitto

      # Generate self-signed TLS certificates
      - name: Generate TLS certificates
        run: |
          # Generate TLS certificates with proper paths
          openssl req -x509 -newkey rsa:2048 \
            -keyout server.key \
            -out server.crt \
            -days 365 \
            -nodes \
            -subj "/CN=host.docker.internal" \
            -addext "subjectAltName=IP:172.17.0.1"
          chmod 600 server.key server.crt

      # Set up kind cluster using the kind-cluster action
      - name: Create kind cluster
        uses: helm/kind-action@v1.12.0
        with:
          registry: true
          registry_name: my-registry
          registry_port: 5000
          registry_enable_delete: true

      # Deploy and test the program
      - name: Deploy and test
        timeout-minutes: 5
        run: |
          # Start the program in the background with process management
          ./kube-mqtt-mirror \
            --webhook \
            --mirror \
            --mqtt-broker tcp://localhost:1883 \
            --webhook-port 8443 \
            --insecure-registries \
            --tls-cert server.crt \
            --tls-key server.key \
            --log-file kube-mqtt-mirror.log & MIRROR_PID=$!
          
          # Function to handle process cleanup
          cleanup_process() {
            local pid=$1
            local name=$2
            local force=${3:-false}
            
            if [ -n "$pid" ] && kill -0 $pid 2>/dev/null; then
              echo "Stopping $name (PID: $pid)"
              kill $pid 2>/dev/null
              
              # Wait for process to stop
              local count=0
              while kill -0 $pid 2>/dev/null && [ $count -lt 10 ]; do
                sleep 1
                count=$((count + 1))
              done
              
              # Force kill if still running and force flag is true
              if [ "$force" = "true" ] && kill -0 $pid 2>/dev/null; then
                echo "Force stopping $name"
                kill -9 $pid 2>/dev/null
              fi
            fi
          }

          # Function to clean up resources
          cleanup() {
            echo "Starting cleanup process..."
            local exit_code=$?
            local signal=$1
            
            # Log cleanup trigger
            if [ -n "$signal" ]; then
              echo "Cleanup triggered by signal: $signal"
            else
              echo "Cleanup triggered by script exit (code: $exit_code)"
            fi
            
            # Stop the mirror process
            if [ -n "$MIRROR_PID" ]; then
              cleanup_process "$MIRROR_PID" "kube-mqtt-mirror" true
            fi

            echo "Cleaning up Kubernetes resources..."
            if [ -f webhook.yaml ]; then
              echo "Removing webhook configuration..."
              kubectl delete -f webhook.yaml --wait=false 2>/dev/null || true
            fi
            
            echo "Removing test pod..."
            kubectl delete pod webhook-test-pod --wait=false --ignore-not-found 2>/dev/null || true
            
            # Show final status
            if [ -f kube-mqtt-mirror.log ]; then
              if [ $exit_code -ne 0 ]; then
                echo "=== Final Program Logs (Exit Code: $exit_code) ==="
                cat kube-mqtt-mirror.log
                echo "=== End Program Logs ==="
              fi
              
              echo "=== Final Pod Status ==="
              kubectl get pods 2>/dev/null || true
            fi
            
            echo "Cleanup completed"
            exit $exit_code
          }
          
          # Set up traps for various signals
          trap 'cleanup SIGTERM' SIGTERM
          trap 'cleanup SIGINT' SIGINT
          trap 'cleanup' EXIT
          
          # Wait for the program to start and verify it's running
          echo "Waiting for program to start..."
          start_timeout=30
          started=false
          
          for i in $(seq 1 $start_timeout); do
            if [ -f kube-mqtt-mirror.log ] && grep -q "Starting server" kube-mqtt-mirror.log; then
              echo "Program started successfully after ${i} seconds"
              started=true
              break
            fi
            
            if ! kill -0 $MIRROR_PID 2>/dev/null; then
              echo "Program crashed during startup (after ${i} seconds)"
              echo "=== Program Logs ==="
              cat kube-mqtt-mirror.log || echo "No logs found"
              echo "=== Process Status ==="
              ps aux | grep kube-mqtt-mirror || true
              exit 1
            fi
            
            if [ $i -eq $start_timeout ]; then
              echo "Timeout waiting for program to start"
              echo "=== Program Logs ==="
              cat kube-mqtt-mirror.log || echo "No logs found"
              echo "=== Process Status ==="
              ps aux | grep kube-mqtt-mirror || true
              exit 1
            fi
            
            echo "Waiting for program to start (${i}/${start_timeout})..."
            sleep 1
          done
          
          if [ "$started" != "true" ]; then
            echo "Program failed to start properly"
            exit 1
          fi
          
          # Create webhook configuration
          CA_BUNDLE=$(cat server.crt | base64 | tr -d '\n')
          cat > webhook.yaml <<EOF
          apiVersion: admissionregistration.k8s.io/v1
          kind: MutatingWebhookConfiguration
          metadata:
            name: webhook-mirroring
          webhooks:
            - name: webhook.mirroring.example.com
              admissionReviewVersions: ["v1"]
              sideEffects: None
              rules:
                - operations: ["CREATE"]
                  apiGroups: [""]
                  apiVersions: ["v1"]
                  resources: ["pods"]
              clientConfig:
                url: "https://172.17.0.1:8443/webhook"
                caBundle: $CA_BUNDLE
              failurePolicy: Fail
          EOF
          
          kubectl apply -f webhook.yaml
          
          # Create test pod
          echo "Creating test pod..."
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: webhook-test-pod
            annotations:
              webhook: "true"
          spec:
            containers:
              - name: nginx
                image: nginx
          EOF
          
          # Wait for pod creation and verify
          echo "Waiting for pod creation..."
          if ! kubectl wait --for=condition=ready pod/webhook-test-pod --timeout=60s; then
            echo "Pod creation failed"
            kubectl describe pod webhook-test-pod
            exit 1
          fi
          
          # Check program logs
          echo "=== Program Logs ==="
          cat kube-mqtt-mirror.log
          
          # Verify program is still running
          if ! kill -0 $MIRROR_PID 2>/dev/null; then
            echo "Program crashed during test"
            exit 1
          fi
          
          # Final verification and cleanup
          echo "=== Final Verification ==="
          echo "Checking program status..."
          if ! kill -0 $MIRROR_PID 2>/dev/null; then
            echo "Program is not running at completion"
            exit 1
          fi
          
          echo "Checking pod status..."
          if ! kubectl get pod webhook-test-pod -o jsonpath='{.status.phase}' | grep -q "Running"; then
            echo "Pod is not running at completion"
            kubectl describe pod webhook-test-pod
            exit 1
          fi
          
          echo "=== Test Summary ==="
          echo "- Program started successfully"
          echo "- Webhook configuration applied"
          echo "- Test pod created and running"
          echo "- All verifications passed"
          echo "Test completed successfully"
